"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./stores/useStore.ts":
/*!****************************!*\
  !*** ./stores/useStore.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n\n\nconst useStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set, get)=>({\n        currentUser: null,\n        isAuthenticated: false,\n        token: null,\n        users: [],\n        projets: [],\n        demandes: [],\n        articles: [],\n        notifications: [],\n        history: [],\n        isLoading: false,\n        error: null,\n        login: async (email, password)=>{\n            set({\n                isLoading: true,\n                error: null\n            });\n            try {\n                const response = await fetch(\"/api/auth/login\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        email,\n                        password\n                    })\n                });\n                const result = await response.json();\n                if (result.success) {\n                    set({\n                        currentUser: result.data.user,\n                        token: result.data.token,\n                        isAuthenticated: true,\n                        isLoading: false\n                    });\n                    return true;\n                } else {\n                    set({\n                        error: result.error,\n                        isLoading: false\n                    });\n                    return false;\n                }\n            } catch (error) {\n                console.error(\"Erreur de connexion:\", error);\n                set({\n                    error: \"Erreur de connexion\",\n                    isLoading: false\n                });\n                return false;\n            }\n        },\n        logout: ()=>{\n            set({\n                currentUser: null,\n                isAuthenticated: false,\n                token: null,\n                users: [],\n                projets: [],\n                demandes: [],\n                notifications: [],\n                history: []\n            });\n        },\n        loadUsers: async ()=>{\n            const { currentUser, token } = get();\n            if (!currentUser || !token) {\n                console.warn(\"Tentative de chargement des utilisateurs sans utilisateur connecté\");\n                return;\n            }\n            try {\n                const response = await fetch(\"/api/users\", {\n                    headers: {\n                        \"Authorization\": \"Bearer \".concat(token)\n                    }\n                });\n                const result = await response.json();\n                if (result.success) {\n                    set({\n                        users: result.data\n                    });\n                } else {\n                    console.error(\"Erreur API users:\", result.error);\n                    set({\n                        error: result.error\n                    });\n                }\n            } catch (error) {\n                console.error(\"Erreur lors du chargement des utilisateurs:\", error);\n                set({\n                    error: \"Erreur lors du chargement des utilisateurs\"\n                });\n            }\n        },\n        loadProjets: async ()=>{\n            const { currentUser } = get();\n            if (!currentUser) {\n                console.warn(\"Tentative de chargement des projets sans utilisateur connecté\");\n                return;\n            }\n            try {\n                console.log(\"Chargement des projets pour l'utilisateur:\", currentUser.id);\n                const response = await fetch(\"/api/projets\", {\n                    headers: {\n                        \"x-user-id\": currentUser.id\n                    }\n                });\n                const result = await response.json();\n                if (result.success) {\n                    console.log(\"Projets chargés:\", result.data.length);\n                    set({\n                        projets: result.data\n                    });\n                } else {\n                    console.error(\"Erreur API projets:\", result.error);\n                    set({\n                        error: result.error\n                    });\n                }\n            } catch (error) {\n                console.error(\"Erreur lors du chargement des projets:\", error);\n                set({\n                    error: \"Erreur lors du chargement des projets\"\n                });\n            }\n        },\n        loadDemandes: async function() {\n            let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            const { currentUser } = get();\n            if (!currentUser) {\n                console.warn(\"Tentative de chargement des demandes sans utilisateur connecté\");\n                return;\n            }\n            try {\n                console.log(\"Chargement des demandes pour l'utilisateur:\", currentUser.id);\n                const params = new URLSearchParams();\n                Object.entries(filters).forEach((param)=>{\n                    let [key, value] = param;\n                    if (value) params.append(key, String(value));\n                });\n                const response = await fetch(\"/api/demandes?\".concat(params), {\n                    headers: {\n                        \"x-user-id\": currentUser.id\n                    }\n                });\n                const result = await response.json();\n                if (result.success) {\n                    console.log(\"Demandes chargées:\", result.data.length);\n                    set({\n                        demandes: result.data\n                    });\n                } else {\n                    console.error(\"Erreur API demandes:\", result.error);\n                    set({\n                        error: result.error\n                    });\n                }\n            } catch (error) {\n                console.error(\"Erreur lors du chargement des demandes:\", error);\n                set({\n                    error: \"Erreur lors du chargement des demandes\"\n                });\n            }\n        },\n        loadArticles: async function() {\n            let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            const { currentUser } = get();\n            if (!currentUser) {\n                console.warn(\"Tentative de chargement des articles sans utilisateur connecté\");\n                return;\n            }\n            try {\n                const params = new URLSearchParams();\n                Object.entries(filters).forEach((param)=>{\n                    let [key, value] = param;\n                    if (value) params.append(key, String(value));\n                });\n                const response = await fetch(\"/api/articles?\".concat(params), {\n                    headers: {\n                        \"x-user-id\": currentUser.id\n                    }\n                });\n                const result = await response.json();\n                if (result.success) {\n                    set({\n                        articles: result.data\n                    });\n                } else {\n                    console.error(\"Erreur API articles:\", result.error);\n                    set({\n                        error: result.error\n                    });\n                }\n            } catch (error) {\n                console.error(\"Erreur lors du chargement des articles:\", error);\n                set({\n                    error: \"Erreur lors du chargement des articles\"\n                });\n            }\n        },\n        loadNotifications: async ()=>{\n            const { currentUser } = get();\n            if (!currentUser) return;\n            try {\n                const response = await fetch(\"/api/notifications\", {\n                    headers: {\n                        \"x-user-id\": currentUser.id\n                    }\n                });\n                const result = await response.json();\n                if (result.success) {\n                    set({\n                        notifications: result.data\n                    });\n                }\n            } catch (error) {\n                console.error(\"Erreur lors du chargement des notifications:\", error);\n            }\n        },\n        loadHistory: async function() {\n            let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            const { currentUser } = get();\n            if (!currentUser) return;\n            try {\n                const params = new URLSearchParams();\n                Object.entries(filters).forEach((param)=>{\n                    let [key, value] = param;\n                    if (value) params.append(key, String(value));\n                });\n                const response = await fetch(\"/api/historique?\".concat(params), {\n                    headers: {\n                        \"x-user-id\": currentUser.id\n                    }\n                });\n                const result = await response.json();\n                if (result.success) {\n                    set({\n                        history: result.data\n                    });\n                }\n            } catch (error) {\n                console.error(\"Erreur lors du chargement de l'historique:\", error);\n            }\n        },\n        createUser: async (userData)=>{\n            const { currentUser, token } = get();\n            if (!currentUser || !token) return false;\n            set({\n                isLoading: true,\n                error: null\n            });\n            try {\n                const response = await fetch(\"/api/users\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        \"Authorization\": \"Bearer \".concat(token)\n                    },\n                    body: JSON.stringify(userData)\n                });\n                const result = await response.json();\n                if (result.success) {\n                    set((state)=>({\n                            users: [\n                                ...state.users,\n                                result.data\n                            ],\n                            isLoading: false\n                        }));\n                    return true;\n                } else {\n                    set({\n                        error: result.error,\n                        isLoading: false\n                    });\n                    return false;\n                }\n            } catch (error) {\n                console.error(\"Erreur création utilisateur:\", error);\n                set({\n                    error: \"Erreur lors de la création de l'utilisateur\",\n                    isLoading: false\n                });\n                return false;\n            }\n        },\n        createProjet: async (projetData)=>{\n            const { currentUser } = get();\n            if (!currentUser) return false;\n            set({\n                isLoading: true,\n                error: null\n            });\n            try {\n                const response = await fetch(\"/api/projets\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        \"x-user-id\": currentUser.id\n                    },\n                    body: JSON.stringify(projetData)\n                });\n                const result = await response.json();\n                if (result.success) {\n                    set((state)=>({\n                            projets: [\n                                ...state.projets,\n                                result.data\n                            ],\n                            isLoading: false\n                        }));\n                    return true;\n                } else {\n                    set({\n                        error: result.error,\n                        isLoading: false\n                    });\n                    return false;\n                }\n            } catch (error) {\n                console.error(\"Erreur création projet:\", error);\n                set({\n                    error: \"Erreur lors de la création du projet\",\n                    isLoading: false\n                });\n                return false;\n            }\n        },\n        createDemande: async (demandeData)=>{\n            const { currentUser } = get();\n            if (!currentUser) return false;\n            set({\n                isLoading: true,\n                error: null\n            });\n            try {\n                const response = await fetch(\"/api/demandes\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        \"x-user-id\": currentUser.id\n                    },\n                    body: JSON.stringify(demandeData)\n                });\n                const result = await response.json();\n                if (result.success) {\n                    set((state)=>({\n                            demandes: [\n                                ...state.demandes,\n                                result.data\n                            ],\n                            isLoading: false\n                        }));\n                    return true;\n                } else {\n                    set({\n                        error: result.error,\n                        isLoading: false\n                    });\n                    return false;\n                }\n            } catch (error) {\n                console.error(\"Erreur création demande:\", error);\n                set({\n                    error: \"Erreur lors de la création de la demande\",\n                    isLoading: false\n                });\n                return false;\n            }\n        },\n        executeAction: async function(demandeId, action) {\n            let data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            const { currentUser } = get();\n            if (!currentUser) return false;\n            try {\n                const response = await fetch(\"/api/demandes/\".concat(demandeId, \"/actions\"), {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        \"x-user-id\": currentUser.id\n                    },\n                    body: JSON.stringify({\n                        action,\n                        ...data\n                    })\n                });\n                const result = await response.json();\n                if (result.success) {\n                    // Mettre à jour la demande dans le store\n                    set((state)=>({\n                            demandes: state.demandes.map((d)=>d.id === demandeId ? result.data.demande : d),\n                            notifications: result.data.notification ? [\n                                result.data.notification,\n                                ...state.notifications\n                            ] : state.notifications,\n                            history: result.data.historyEntry ? [\n                                result.data.historyEntry,\n                                ...state.history\n                            ] : state.history\n                        }));\n                    return true;\n                } else {\n                    set({\n                        error: result.error\n                    });\n                    return false;\n                }\n            } catch (error) {\n                console.error(\"Erreur lors de l'exécution de l'action:\", error);\n                set({\n                    error: \"Erreur lors de l'exécution de l'action\"\n                });\n                return false;\n            }\n        },\n        markNotificationAsRead: async (id)=>{\n            const { currentUser } = get();\n            if (!currentUser) return;\n            try {\n                const response = await fetch(\"/api/notifications/\".concat(id, \"/read\"), {\n                    method: \"PUT\",\n                    headers: {\n                        \"x-user-id\": currentUser.id\n                    }\n                });\n                const result = await response.json();\n                if (result.success) {\n                    set((state)=>({\n                            notifications: state.notifications.map((n)=>n.id === id ? {\n                                    ...n,\n                                    lu: true\n                                } : n)\n                        }));\n                }\n            } catch (error) {\n                console.error(\"Erreur lors de la mise à jour de la notification:\", error);\n            }\n        },\n        setLoading: (loading)=>set({\n                isLoading: loading\n            }),\n        setError: (error)=>set({\n                error\n            }),\n        setDemandes: (demandes)=>set({\n                demandes\n            }),\n        setArticles: (articles)=>set({\n                articles\n            }),\n        addDemande: (demande)=>set((state)=>({\n                    demandes: [\n                        ...state.demandes,\n                        demande\n                    ]\n                })),\n        updateDemande: (id, demande)=>set((state)=>({\n                    demandes: state.demandes.map((d)=>d.id === id ? demande : d)\n                })),\n        addNotification: (notification)=>set((state)=>({\n                    notifications: [\n                        notification,\n                        ...state.notifications\n                    ]\n                })),\n        addHistoryEntry: (entry)=>set((state)=>({\n                    history: [\n                        entry,\n                        ...state.history\n                    ]\n                }))\n    }), {\n    name: \"gestion-demandes-achat-storage\",\n    partialize: (state)=>({\n            currentUser: state.currentUser,\n            isAuthenticated: state.isAuthenticated,\n            token: state.token\n        })\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aEUsV0FBd0JQLElBQUk7Z0JBQUVPO1lBQVM7UUFDckRpRSxhQUFhLENBQUNoRSxXQUF3QlIsSUFBSTtnQkFBRVE7WUFBUztRQUNyRGlFLFlBQVksQ0FBQ1gsVUFBcUI5RCxJQUFJLENBQUNvRCxRQUFXO29CQUFFN0MsVUFBVTsyQkFBSTZDLE1BQU03QyxRQUFRO3dCQUFFdUQ7cUJBQVE7Z0JBQUM7UUFDM0ZZLGVBQWUsQ0FBQ3hDLElBQVk0QixVQUMxQjlELElBQUksQ0FBQ29ELFFBQVc7b0JBQ2Q3QyxVQUFVNkMsTUFBTTdDLFFBQVEsQ0FBQ3FELEdBQUcsQ0FBQyxDQUFDQyxJQUFPQSxFQUFFM0IsRUFBRSxLQUFLQSxLQUFLNEIsVUFBVUQ7Z0JBQy9EO1FBQ0ZjLGlCQUFpQixDQUFDWixlQUNoQi9ELElBQUksQ0FBQ29ELFFBQVc7b0JBQ2QzQyxlQUFlO3dCQUFDc0Q7MkJBQWlCWCxNQUFNM0MsYUFBYTtxQkFBQztnQkFDdkQ7UUFDRm1FLGlCQUFpQixDQUFDQyxRQUNoQjdFLElBQUksQ0FBQ29ELFFBQVc7b0JBQ2QxQyxTQUFTO3dCQUFDbUU7MkJBQVV6QixNQUFNMUMsT0FBTztxQkFBQztnQkFDcEM7SUFDSixJQUNBO0lBQ0VvRSxNQUFNO0lBQ05DLFlBQVksQ0FBQzNCLFFBQVc7WUFDdEJsRCxhQUFha0QsTUFBTWxELFdBQVc7WUFDOUJDLGlCQUFpQmlELE1BQU1qRCxlQUFlO1lBQ3RDQyxPQUFPZ0QsTUFBTWhELEtBQUs7UUFDcEI7QUFDRixJQUVIIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExlbm92b1xcT25lRHJpdmVcXERlc2t0b3BcXGdlc3Rpb24tZGVtYW5kZXMtbWF0ZXJpZWwgKDcpXFxzdG9yZXNcXHVzZVN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gXCJ6dXN0YW5kXCJcbmltcG9ydCB7IHBlcnNpc3QgfSBmcm9tIFwienVzdGFuZC9taWRkbGV3YXJlXCJcbmltcG9ydCB0eXBlIHsgVXNlciwgUHJvamV0LCBEZW1hbmRlLCBBcnRpY2xlLCBOb3RpZmljYXRpb24sIEhpc3RvcnlFbnRyeSB9IGZyb20gXCJAL3R5cGVzXCJcblxuaW50ZXJmYWNlIEFwcFN0YXRlIHtcbiAgLy8gQXV0aFxuICBjdXJyZW50VXNlcjogVXNlciB8IG51bGxcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuXG4gIHRva2VuOiBzdHJpbmcgfCBudWxsXG5cbiAgLy8gRGF0YVxuICB1c2VyczogVXNlcltdXG4gIHByb2pldHM6IFByb2pldFtdXG4gIGRlbWFuZGVzOiBEZW1hbmRlW11cbiAgYXJ0aWNsZXM6IEFydGljbGVbXVxuICBub3RpZmljYXRpb25zOiBOb3RpZmljYXRpb25bXVxuICBoaXN0b3J5OiBIaXN0b3J5RW50cnlbXVxuXG4gIC8vIFVJIFN0YXRlXG4gIGlzTG9hZGluZzogYm9vbGVhblxuICBlcnJvcjogc3RyaW5nIHwgbnVsbFxuXG4gIC8vIEFjdGlvbnNcbiAgbG9naW46IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+XG4gIGxvZ291dDogKCkgPT4gdm9pZFxuICBsb2FkVXNlcnM6ICgpID0+IFByb21pc2U8dm9pZD5cbiAgbG9hZFByb2pldHM6ICgpID0+IFByb21pc2U8dm9pZD5cbiAgbG9hZERlbWFuZGVzOiAoZmlsdGVycz86IGFueSkgPT4gUHJvbWlzZTx2b2lkPlxuICBsb2FkQXJ0aWNsZXM6IChmaWx0ZXJzPzogYW55KSA9PiBQcm9taXNlPHZvaWQ+XG4gIGxvYWROb3RpZmljYXRpb25zOiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4gIGxvYWRIaXN0b3J5OiAoZmlsdGVycz86IGFueSkgPT4gUHJvbWlzZTx2b2lkPlxuICBjcmVhdGVVc2VyOiAodXNlckRhdGE6IFBhcnRpYWw8VXNlcj4pID0+IFByb21pc2U8Ym9vbGVhbj5cbiAgY3JlYXRlUHJvamV0OiAocHJvamV0RGF0YTogUGFydGlhbDxQcm9qZXQ+KSA9PiBQcm9taXNlPGJvb2xlYW4+XG4gIGNyZWF0ZURlbWFuZGU6IChkZW1hbmRlRGF0YTogUGFydGlhbDxEZW1hbmRlPikgPT4gUHJvbWlzZTxib29sZWFuPlxuICBleGVjdXRlQWN0aW9uOiAoZGVtYW5kZUlkOiBzdHJpbmcsIGFjdGlvbjogc3RyaW5nLCBkYXRhPzogYW55KSA9PiBQcm9taXNlPGJvb2xlYW4+XG4gIG1hcmtOb3RpZmljYXRpb25Bc1JlYWQ6IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+XG4gIHNldExvYWRpbmc6IChsb2FkaW5nOiBib29sZWFuKSA9PiB2b2lkXG4gIHNldEVycm9yOiAoZXJyb3I6IHN0cmluZyB8IG51bGwpID0+IHZvaWRcbiAgc2V0RGVtYW5kZXM6IChkZW1hbmRlczogRGVtYW5kZVtdKSA9PiB2b2lkXG4gIHNldEFydGljbGVzOiAoYXJ0aWNsZXM6IEFydGljbGVbXSkgPT4gdm9pZFxuICBhZGREZW1hbmRlOiAoZGVtYW5kZTogRGVtYW5kZSkgPT4gdm9pZFxuICB1cGRhdGVEZW1hbmRlOiAoaWQ6IHN0cmluZywgZGVtYW5kZTogRGVtYW5kZSkgPT4gdm9pZFxuICBhZGROb3RpZmljYXRpb246IChub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbikgPT4gdm9pZFxuICBhZGRIaXN0b3J5RW50cnk6IChlbnRyeTogSGlzdG9yeUVudHJ5KSA9PiB2b2lkXG59XG5cbmV4cG9ydCBjb25zdCB1c2VTdG9yZSA9IGNyZWF0ZTxBcHBTdGF0ZT4oKShcbiAgcGVyc2lzdChcbiAgICAoc2V0LCBnZXQpID0+ICh7XG4gICAgICBjdXJyZW50VXNlcjogbnVsbCxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICB0b2tlbjogbnVsbCxcbiAgICAgIHVzZXJzOiBbXSxcbiAgICAgIHByb2pldHM6IFtdLFxuICAgICAgZGVtYW5kZXM6IFtdLFxuICAgICAgYXJ0aWNsZXM6IFtdLFxuICAgICAgbm90aWZpY2F0aW9uczogW10sXG4gICAgICBoaXN0b3J5OiBbXSxcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBlcnJvcjogbnVsbCxcblxuICAgICAgbG9naW46IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIHNldCh7IGlzTG9hZGluZzogdHJ1ZSwgZXJyb3I6IG51bGwgfSlcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCIvYXBpL2F1dGgvbG9naW5cIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgcGFzc3dvcmQgfSksXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBjdXJyZW50VXNlcjogcmVzdWx0LmRhdGEudXNlcixcbiAgICAgICAgICAgICAgdG9rZW46IHJlc3VsdC5kYXRhLnRva2VuLFxuICAgICAgICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0KHsgZXJyb3I6IHJlc3VsdC5lcnJvciwgaXNMb2FkaW5nOiBmYWxzZSB9KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJldXIgZGUgY29ubmV4aW9uOlwiLCBlcnJvcilcbiAgICAgICAgICBzZXQoeyBlcnJvcjogXCJFcnJldXIgZGUgY29ubmV4aW9uXCIsIGlzTG9hZGluZzogZmFsc2UgfSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbG9nb3V0OiAoKSA9PiB7XG4gICAgICAgIHNldCh7XG4gICAgICAgICAgY3VycmVudFVzZXI6IG51bGwsXG4gICAgICAgICAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICB1c2VyczogW10sXG4gICAgICAgICAgcHJvamV0czogW10sXG4gICAgICAgICAgZGVtYW5kZXM6IFtdLFxuICAgICAgICAgIG5vdGlmaWNhdGlvbnM6IFtdLFxuICAgICAgICAgIGhpc3Rvcnk6IFtdLFxuICAgICAgICB9KVxuICAgICAgfSxcblxuICAgICAgbG9hZFVzZXJzOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFVzZXIsIHRva2VuIH0gPSBnZXQoKVxuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyIHx8ICF0b2tlbikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRlbnRhdGl2ZSBkZSBjaGFyZ2VtZW50IGRlcyB1dGlsaXNhdGV1cnMgc2FucyB1dGlsaXNhdGV1ciBjb25uZWN0w6lcIilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvdXNlcnNcIiwge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHNldCh7IHVzZXJzOiByZXN1bHQuZGF0YSB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyZXVyIEFQSSB1c2VyczpcIiwgcmVzdWx0LmVycm9yKVxuICAgICAgICAgICAgc2V0KHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyZXVyIGxvcnMgZHUgY2hhcmdlbWVudCBkZXMgdXRpbGlzYXRldXJzOlwiLCBlcnJvcilcbiAgICAgICAgICBzZXQoeyBlcnJvcjogXCJFcnJldXIgbG9ycyBkdSBjaGFyZ2VtZW50IGRlcyB1dGlsaXNhdGV1cnNcIiB9KVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBsb2FkUHJvamV0czogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRVc2VyIH0gPSBnZXQoKVxuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVGVudGF0aXZlIGRlIGNoYXJnZW1lbnQgZGVzIHByb2pldHMgc2FucyB1dGlsaXNhdGV1ciBjb25uZWN0w6lcIilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJDaGFyZ2VtZW50IGRlcyBwcm9qZXRzIHBvdXIgbCd1dGlsaXNhdGV1cjpcIiwgY3VycmVudFVzZXIuaWQpXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvcHJvamV0c1wiLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwieC11c2VyLWlkXCI6IGN1cnJlbnRVc2VyLmlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlByb2pldHMgY2hhcmfDqXM6XCIsIHJlc3VsdC5kYXRhLmxlbmd0aClcbiAgICAgICAgICAgIHNldCh7IHByb2pldHM6IHJlc3VsdC5kYXRhIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJldXIgQVBJIHByb2pldHM6XCIsIHJlc3VsdC5lcnJvcilcbiAgICAgICAgICAgIHNldCh7IGVycm9yOiByZXN1bHQuZXJyb3IgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycmV1ciBsb3JzIGR1IGNoYXJnZW1lbnQgZGVzIHByb2pldHM6XCIsIGVycm9yKVxuICAgICAgICAgIHNldCh7IGVycm9yOiBcIkVycmV1ciBsb3JzIGR1IGNoYXJnZW1lbnQgZGVzIHByb2pldHNcIiB9KVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBsb2FkRGVtYW5kZXM6IGFzeW5jIChmaWx0ZXJzID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VXNlciB9ID0gZ2V0KClcbiAgICAgICAgaWYgKCFjdXJyZW50VXNlcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRlbnRhdGl2ZSBkZSBjaGFyZ2VtZW50IGRlcyBkZW1hbmRlcyBzYW5zIHV0aWxpc2F0ZXVyIGNvbm5lY3TDqVwiKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkNoYXJnZW1lbnQgZGVzIGRlbWFuZGVzIHBvdXIgbCd1dGlsaXNhdGV1cjpcIiwgY3VycmVudFVzZXIuaWQpXG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoZmlsdGVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHBhcmFtcy5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RlbWFuZGVzPyR7cGFyYW1zfWAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgXCJ4LXVzZXItaWRcIjogY3VycmVudFVzZXIuaWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRGVtYW5kZXMgY2hhcmfDqWVzOlwiLCByZXN1bHQuZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICBzZXQoeyBkZW1hbmRlczogcmVzdWx0LmRhdGEgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycmV1ciBBUEkgZGVtYW5kZXM6XCIsIHJlc3VsdC5lcnJvcilcbiAgICAgICAgICAgIHNldCh7IGVycm9yOiByZXN1bHQuZXJyb3IgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycmV1ciBsb3JzIGR1IGNoYXJnZW1lbnQgZGVzIGRlbWFuZGVzOlwiLCBlcnJvcilcbiAgICAgICAgICBzZXQoeyBlcnJvcjogXCJFcnJldXIgbG9ycyBkdSBjaGFyZ2VtZW50IGRlcyBkZW1hbmRlc1wiIH0pXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxvYWRBcnRpY2xlczogYXN5bmMgKGZpbHRlcnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRVc2VyIH0gPSBnZXQoKVxuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVGVudGF0aXZlIGRlIGNoYXJnZW1lbnQgZGVzIGFydGljbGVzIHNhbnMgdXRpbGlzYXRldXIgY29ubmVjdMOpXCIpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSBwYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9hcnRpY2xlcz8ke3BhcmFtc31gLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwieC11c2VyLWlkXCI6IGN1cnJlbnRVc2VyLmlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBzZXQoeyBhcnRpY2xlczogcmVzdWx0LmRhdGEgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycmV1ciBBUEkgYXJ0aWNsZXM6XCIsIHJlc3VsdC5lcnJvcilcbiAgICAgICAgICAgIHNldCh7IGVycm9yOiByZXN1bHQuZXJyb3IgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycmV1ciBsb3JzIGR1IGNoYXJnZW1lbnQgZGVzIGFydGljbGVzOlwiLCBlcnJvcilcbiAgICAgICAgICBzZXQoeyBlcnJvcjogXCJFcnJldXIgbG9ycyBkdSBjaGFyZ2VtZW50IGRlcyBhcnRpY2xlc1wiIH0pXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxvYWROb3RpZmljYXRpb25zOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFVzZXIgfSA9IGdldCgpXG4gICAgICAgIGlmICghY3VycmVudFVzZXIpIHJldHVyblxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvbm90aWZpY2F0aW9uc1wiLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwieC11c2VyLWlkXCI6IGN1cnJlbnRVc2VyLmlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBzZXQoeyBub3RpZmljYXRpb25zOiByZXN1bHQuZGF0YSB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyZXVyIGxvcnMgZHUgY2hhcmdlbWVudCBkZXMgbm90aWZpY2F0aW9uczpcIiwgZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxvYWRIaXN0b3J5OiBhc3luYyAoZmlsdGVycyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFVzZXIgfSA9IGdldCgpXG4gICAgICAgIGlmICghY3VycmVudFVzZXIpIHJldHVyblxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoZmlsdGVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHBhcmFtcy5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2hpc3RvcmlxdWU/JHtwYXJhbXN9YCwge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIngtdXNlci1pZFwiOiBjdXJyZW50VXNlci5pZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgc2V0KHsgaGlzdG9yeTogcmVzdWx0LmRhdGEgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycmV1ciBsb3JzIGR1IGNoYXJnZW1lbnQgZGUgbCdoaXN0b3JpcXVlOlwiLCBlcnJvcilcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY3JlYXRlVXNlcjogYXN5bmMgKHVzZXJEYXRhOiBQYXJ0aWFsPFVzZXI+KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFVzZXIsIHRva2VuIH0gPSBnZXQoKVxuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyIHx8ICF0b2tlbikgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgc2V0KHsgaXNMb2FkaW5nOiB0cnVlLCBlcnJvcjogbnVsbCB9KVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvdXNlcnNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSksXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgICAgdXNlcnM6IFsuLi5zdGF0ZS51c2VycywgcmVzdWx0LmRhdGFdLFxuICAgICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQoeyBlcnJvcjogcmVzdWx0LmVycm9yLCBpc0xvYWRpbmc6IGZhbHNlIH0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycmV1ciBjcsOpYXRpb24gdXRpbGlzYXRldXI6XCIsIGVycm9yKVxuICAgICAgICAgIHNldCh7IGVycm9yOiBcIkVycmV1ciBsb3JzIGRlIGxhIGNyw6lhdGlvbiBkZSBsJ3V0aWxpc2F0ZXVyXCIsIGlzTG9hZGluZzogZmFsc2UgfSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY3JlYXRlUHJvamV0OiBhc3luYyAocHJvamV0RGF0YTogUGFydGlhbDxQcm9qZXQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFVzZXIgfSA9IGdldCgpXG4gICAgICAgIGlmICghY3VycmVudFVzZXIpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIHNldCh7IGlzTG9hZGluZzogdHJ1ZSwgZXJyb3I6IG51bGwgfSlcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCIvYXBpL3Byb2pldHNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgIFwieC11c2VyLWlkXCI6IGN1cnJlbnRVc2VyLmlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb2pldERhdGEpLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgIHByb2pldHM6IFsuLi5zdGF0ZS5wcm9qZXRzLCByZXN1bHQuZGF0YV0sXG4gICAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCh7IGVycm9yOiByZXN1bHQuZXJyb3IsIGlzTG9hZGluZzogZmFsc2UgfSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyZXVyIGNyw6lhdGlvbiBwcm9qZXQ6XCIsIGVycm9yKVxuICAgICAgICAgIHNldCh7IGVycm9yOiBcIkVycmV1ciBsb3JzIGRlIGxhIGNyw6lhdGlvbiBkdSBwcm9qZXRcIiwgaXNMb2FkaW5nOiBmYWxzZSB9KVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjcmVhdGVEZW1hbmRlOiBhc3luYyAoZGVtYW5kZURhdGE6IFBhcnRpYWw8RGVtYW5kZT4pID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VXNlciB9ID0gZ2V0KClcbiAgICAgICAgaWYgKCFjdXJyZW50VXNlcikgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgc2V0KHsgaXNMb2FkaW5nOiB0cnVlLCBlcnJvcjogbnVsbCB9KVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvZGVtYW5kZXNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgIFwieC11c2VyLWlkXCI6IGN1cnJlbnRVc2VyLmlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRlbWFuZGVEYXRhKSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICBkZW1hbmRlczogWy4uLnN0YXRlLmRlbWFuZGVzLCByZXN1bHQuZGF0YV0sXG4gICAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCh7IGVycm9yOiByZXN1bHQuZXJyb3IsIGlzTG9hZGluZzogZmFsc2UgfSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyZXVyIGNyw6lhdGlvbiBkZW1hbmRlOlwiLCBlcnJvcilcbiAgICAgICAgICBzZXQoeyBlcnJvcjogXCJFcnJldXIgbG9ycyBkZSBsYSBjcsOpYXRpb24gZGUgbGEgZGVtYW5kZVwiLCBpc0xvYWRpbmc6IGZhbHNlIH0pXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV4ZWN1dGVBY3Rpb246IGFzeW5jIChkZW1hbmRlSWQ6IHN0cmluZywgYWN0aW9uOiBzdHJpbmcsIGRhdGEgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRVc2VyIH0gPSBnZXQoKVxuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyKSByZXR1cm4gZmFsc2VcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZGVtYW5kZXMvJHtkZW1hbmRlSWR9L2FjdGlvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgXCJ4LXVzZXItaWRcIjogY3VycmVudFVzZXIuaWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBhY3Rpb24sIC4uLmRhdGEgfSksXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gTWV0dHJlIMOgIGpvdXIgbGEgZGVtYW5kZSBkYW5zIGxlIHN0b3JlXG4gICAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICBkZW1hbmRlczogc3RhdGUuZGVtYW5kZXMubWFwKChkKSA9PiAoZC5pZCA9PT0gZGVtYW5kZUlkID8gcmVzdWx0LmRhdGEuZGVtYW5kZSA6IGQpKSxcbiAgICAgICAgICAgICAgbm90aWZpY2F0aW9uczogcmVzdWx0LmRhdGEubm90aWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgPyBbcmVzdWx0LmRhdGEubm90aWZpY2F0aW9uLCAuLi5zdGF0ZS5ub3RpZmljYXRpb25zXVxuICAgICAgICAgICAgICAgIDogc3RhdGUubm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgICAgaGlzdG9yeTogcmVzdWx0LmRhdGEuaGlzdG9yeUVudHJ5XG4gICAgICAgICAgICAgICAgPyBbcmVzdWx0LmRhdGEuaGlzdG9yeUVudHJ5LCAuLi5zdGF0ZS5oaXN0b3J5XVxuICAgICAgICAgICAgICAgIDogc3RhdGUuaGlzdG9yeSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0KHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJldXIgbG9ycyBkZSBsJ2V4w6ljdXRpb24gZGUgbCdhY3Rpb246XCIsIGVycm9yKVxuICAgICAgICAgIHNldCh7IGVycm9yOiBcIkVycmV1ciBsb3JzIGRlIGwnZXjDqWN1dGlvbiBkZSBsJ2FjdGlvblwiIH0pXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG1hcmtOb3RpZmljYXRpb25Bc1JlYWQ6IGFzeW5jIChpZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFVzZXIgfSA9IGdldCgpXG4gICAgICAgIGlmICghY3VycmVudFVzZXIpIHJldHVyblxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9ub3RpZmljYXRpb25zLyR7aWR9L3JlYWRgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwieC11c2VyLWlkXCI6IGN1cnJlbnRVc2VyLmlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICBub3RpZmljYXRpb25zOiBzdGF0ZS5ub3RpZmljYXRpb25zLm1hcCgobikgPT4gKG4uaWQgPT09IGlkID8geyAuLi5uLCBsdTogdHJ1ZSB9IDogbikpLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJldXIgbG9ycyBkZSBsYSBtaXNlIMOgIGpvdXIgZGUgbGEgbm90aWZpY2F0aW9uOlwiLCBlcnJvcilcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc2V0TG9hZGluZzogKGxvYWRpbmc6IGJvb2xlYW4pID0+IHNldCh7IGlzTG9hZGluZzogbG9hZGluZyB9KSxcbiAgICAgIHNldEVycm9yOiAoZXJyb3I6IHN0cmluZyB8IG51bGwpID0+IHNldCh7IGVycm9yIH0pLFxuICAgICAgc2V0RGVtYW5kZXM6IChkZW1hbmRlczogRGVtYW5kZVtdKSA9PiBzZXQoeyBkZW1hbmRlcyB9KSxcbiAgICAgIHNldEFydGljbGVzOiAoYXJ0aWNsZXM6IEFydGljbGVbXSkgPT4gc2V0KHsgYXJ0aWNsZXMgfSksXG4gICAgICBhZGREZW1hbmRlOiAoZGVtYW5kZTogRGVtYW5kZSkgPT4gc2V0KChzdGF0ZSkgPT4gKHsgZGVtYW5kZXM6IFsuLi5zdGF0ZS5kZW1hbmRlcywgZGVtYW5kZV0gfSkpLFxuICAgICAgdXBkYXRlRGVtYW5kZTogKGlkOiBzdHJpbmcsIGRlbWFuZGU6IERlbWFuZGUpID0+XG4gICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgZGVtYW5kZXM6IHN0YXRlLmRlbWFuZGVzLm1hcCgoZCkgPT4gKGQuaWQgPT09IGlkID8gZGVtYW5kZSA6IGQpKSxcbiAgICAgICAgfSkpLFxuICAgICAgYWRkTm90aWZpY2F0aW9uOiAobm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24pID0+XG4gICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgbm90aWZpY2F0aW9uczogW25vdGlmaWNhdGlvbiwgLi4uc3RhdGUubm90aWZpY2F0aW9uc10sXG4gICAgICAgIH0pKSxcbiAgICAgIGFkZEhpc3RvcnlFbnRyeTogKGVudHJ5OiBIaXN0b3J5RW50cnkpID0+XG4gICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgaGlzdG9yeTogW2VudHJ5LCAuLi5zdGF0ZS5oaXN0b3J5XSxcbiAgICAgICAgfSkpLFxuICAgIH0pLFxuICAgIHtcbiAgICAgIG5hbWU6IFwiZ2VzdGlvbi1kZW1hbmRlcy1hY2hhdC1zdG9yYWdlXCIsXG4gICAgICBwYXJ0aWFsaXplOiAoc3RhdGUpID0+ICh7XG4gICAgICAgIGN1cnJlbnRVc2VyOiBzdGF0ZS5jdXJyZW50VXNlcixcbiAgICAgICAgaXNBdXRoZW50aWNhdGVkOiBzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQsXG4gICAgICAgIHRva2VuOiBzdGF0ZS50b2tlbixcbiAgICAgIH0pLFxuICAgIH0sXG4gICksXG4pXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwicGVyc2lzdCIsInVzZVN0b3JlIiwic2V0IiwiZ2V0IiwiY3VycmVudFVzZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJ0b2tlbiIsInVzZXJzIiwicHJvamV0cyIsImRlbWFuZGVzIiwiYXJ0aWNsZXMiLCJub3RpZmljYXRpb25zIiwiaGlzdG9yeSIsImlzTG9hZGluZyIsImVycm9yIiwibG9naW4iLCJlbWFpbCIsInBhc3N3b3JkIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3VsdCIsImpzb24iLCJzdWNjZXNzIiwiZGF0YSIsInVzZXIiLCJjb25zb2xlIiwibG9nb3V0IiwibG9hZFVzZXJzIiwid2FybiIsImxvYWRQcm9qZXRzIiwibG9nIiwiaWQiLCJsZW5ndGgiLCJsb2FkRGVtYW5kZXMiLCJmaWx0ZXJzIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsImFwcGVuZCIsIlN0cmluZyIsImxvYWRBcnRpY2xlcyIsImxvYWROb3RpZmljYXRpb25zIiwibG9hZEhpc3RvcnkiLCJjcmVhdGVVc2VyIiwidXNlckRhdGEiLCJzdGF0ZSIsImNyZWF0ZVByb2pldCIsInByb2pldERhdGEiLCJjcmVhdGVEZW1hbmRlIiwiZGVtYW5kZURhdGEiLCJleGVjdXRlQWN0aW9uIiwiZGVtYW5kZUlkIiwiYWN0aW9uIiwibWFwIiwiZCIsImRlbWFuZGUiLCJub3RpZmljYXRpb24iLCJoaXN0b3J5RW50cnkiLCJtYXJrTm90aWZpY2F0aW9uQXNSZWFkIiwibiIsImx1Iiwic2V0TG9hZGluZyIsImxvYWRpbmciLCJzZXRFcnJvciIsInNldERlbWFuZGVzIiwic2V0QXJ0aWNsZXMiLCJhZGREZW1hbmRlIiwidXBkYXRlRGVtYW5kZSIsImFkZE5vdGlmaWNhdGlvbiIsImFkZEhpc3RvcnlFbnRyeSIsImVudHJ5IiwibmFtZSIsInBhcnRpYWxpemUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./stores/useStore.ts\n"));

/***/ })

});